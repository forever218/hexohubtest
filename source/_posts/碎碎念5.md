---
title: ç¢ç¢å¿µ5
date: 2025-07-20 17:13:23
tags:
- ç”Ÿæ´»
- æ‚å¿µ
- æƒ³å…¥éé
- æ—¥å¸¸
cover: 24.jpg
background: url(24.jpg)
publish_location: å±±è¥¿çœ-å¤ªåŸå¸‚-å°–è‰åªåŒº
---

{% note info modern %}
å¥½ä¹…æ²¡å†™ç¢ç¢å¿µäº†ï¼Œä¸ªäººæ¥è¯´æˆ‘ä¸æ˜¯å¾ˆå–œæ¬¢è¿™ä¸ªæ ‡é¢˜ï¼Œæœ‰ä¸€ç§æ•·è¡çš„æ„Ÿè§‰ï¼Œè®©è¯»è€…ä¸èƒ½ä¸€çœ¼çœ‹å‡ºæ–‡ç« ä¸»é¢˜ã€‚ä½†æ˜¯å¥ˆä½•çäº‹ç¹å¤šï¼Œæ„Ÿè§‰æœ‰å¾ˆå¤šä¹±ä¸ƒå…«ç³Ÿçš„ä¸œè¥¿æƒ³å†™ï¼Œè¿˜æ˜¯å°†æœ¬ç¯‡æ–‡ç« å‘½åä¸º**ç¢ç¢å¿µ5**ã€‚
{% endnote %}

# YOLOæ£€æµ‹
&nbsp; &nbsp; &nbsp; å‰ä¸ä¹…å†™äº†ç¯‡æ–‡ç« ï¼Œè¯¦ç»†è®²è¿°äº†ç”¨yolov11è®­ç»ƒä¸€ä¸ªæ— äººæœºæ£€æµ‹æ¨¡å‹çš„é¡¹ç›®ï¼Œå¦‚æœæ„Ÿå…´è¶£ï¼Œå¯ä»¥{% btn 'https://2am.top/2025/03/23/%E5%9F%BA%E4%BA%8EYOLO11%E7%9A%84%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/',å»çœ‹çœ‹,far fa-hand-point-right,blue larger %}ã€‚
&nbsp; &nbsp; &nbsp; åæ¥å‘ç°ç¦»è¯¾è®¾æˆªè‡³æ—¥æœŸè¿˜æœ‰ç‚¹æ—¶é—´ï¼Œå°±æ¢äº†ä¸€ä¸ªæ›´å¤§çš„æ¨¡å‹æƒé‡ï¼Œé‡æ–°è¿›è¡Œä¸€æ¬¡è®­ç»ƒã€‚åœ¨ä¸Šä¸€ç¯‡æ–‡ç« é‡Œæˆ‘æåˆ°çš„ç”¨yolo11nè¿›è¡Œè®­ç»ƒï¼Œç”±äºæƒé‡å¤ªå°ï¼Œå¯¼è‡´æ¨¡å‹çš„ç²¾åº¦ä¸é«˜ï¼Œæ£€æµ‹æ•ˆæœä¹Ÿä¸ç†æƒ³ï¼Œè€Œä¸”åæ¥ä¹Ÿå‘ç°æ²¡æœ‰åµŒå…¥å¼éƒ¨ç½²çš„éœ€æ±‚ï¼ˆä¸éœ€è¦è½»é‡åŒ–ï¼‰ï¼Œè¿™æ¬¡å°±æ¢äº†ä¸ªyolo11Lï¼Œå‚é‡æ˜¯yolo11nçš„10å€ï¼Œåœ¨ç›¸åŒçš„è®­ç»ƒæ¡ä»¶ä¸‹ï¼Œæ£€æµ‹ç²¾åº¦æœ‰äº†å¤§å¹…åº¦çš„æé«˜ï¼ˆmAP@0.5è¾¾åˆ°96%ï¼ŒmAP@0.5:0.95çº¦74%ï¼‰ï¼Œå…·ä½“çš„è®­ç»ƒæˆæœå·²ç»å‘å¸ƒåœ¨äº†{% btn 'https://github.com/forever218/YOLO-Drone-Detection',github,far fa-hand-point-right,green larger %}ä¸Šã€‚
{%asset_img 1.png %}
&nbsp; &nbsp; &nbsp; ä¸Šå›¾ä¸­ï¼Œå·¦è¾¹10å¼ æ˜¯11Lçš„ç»“æœï¼Œå³è¾¹10å¼ æ˜¯11nçš„ç»“æœã€‚ä¸‹é¢æ˜¯å¯¹11Læ›´ç›´è§‚çš„åˆ†æå›¾ã€‚
{%asset_img 0.png %}
&nbsp; &nbsp; &nbsp; å¤§æ¦‚æ˜¯äº”æœˆä¸­çš„æ—¶å€™å®Œæˆæœ€ç»ˆçš„æ¨¡å‹è®­ç»ƒï¼Œç„¶åæ•´ä¸ªäººä¸€ä¸‹å°±é˜³ç—¿äº†å¾ˆä¹…ï¼Œåšè¿™ä¸ªå¤ªè´¹ç²¾åŠ›äº†ğŸ˜«ã€‚åé¢ï¼ˆç›´åˆ°ç°åœ¨ï¼‰ä¹Ÿæ²¡åœ¨ç›®æ ‡æ£€æµ‹æ–¹é¢æ‰¾åˆ°ä»€ä¹ˆæœ‰åˆ›é€ æ€§çš„å°è¯•ï¼Œäºæ˜¯å°±æç½®äº†ä¸‹æ¥ï¼ˆå±äºæ˜¯ä¸€ä¸ª11Lç»™æˆ‘è®­é˜³ç—¿äº†ï¼‰ã€‚
&nbsp; &nbsp; &nbsp; å¦å¤–è¿™é‡Œè´´ä¸€ä¸ªæŒºå¥½ç”¨çš„Pythonç¨‹åºï¼Œèƒ½å°†è®­ç»ƒå®Œæˆçš„æ¨¡å‹å‚æ•°åšä¸€ä¸ªå¯è§†åŒ–çš„åˆ†æï¼Œæœ‰æ—¶å®ƒé‚£ä¸ªé»˜è®¤çš„åˆ†æå›¾ä¸æ˜¯å¾ˆæ¸…æ™°ï¼Œä¸Šé¢é‚£ä¸ªå½©è‰²çš„åˆ†æå›¾å°±æ˜¯ç”±è¯¥ç¨‹åºè¾“å‡ºçš„ï¼š
```python
import pandas as pd
import matplotlib.pyplot as plt

# è¯»å– CSV æ–‡ä»¶
df = pd.read_csv("results.csv")

# è®¾ç½®å›¾åƒå¤§å°
plt.figure(figsize=(16, 10))

# ---------------------- å›¾1ï¼šLoss æ›²çº¿ ----------------------
plt.subplot(2, 2, 1)
plt.plot(df["epoch"], df["train/box_loss"], label="Train Box Loss", color='blue')
plt.plot(df["epoch"], df["val/box_loss"], label="Val Box Loss", linestyle='--', color='blue')
plt.plot(df["epoch"], df["train/cls_loss"], label="Train Cls Loss", color='green')
plt.plot(df["epoch"], df["val/cls_loss"], label="Val Cls Loss", linestyle='--', color='green')
plt.plot(df["epoch"], df["train/dfl_loss"], label="Train DFL Loss", color='red')
plt.plot(df["epoch"], df["val/dfl_loss"], label="Val DFL Loss", linestyle='--', color='red')
plt.title("Box/Cls/DFL Loss")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.grid(True)

# ---------------------- å›¾2ï¼šPrecision æ›²çº¿ ----------------------
plt.subplot(2, 2, 2)
plt.plot(df["epoch"], df["metrics/precision(B)"], label="Precision", color='orange')
plt.title("Precision over Epochs")
plt.xlabel("Epoch")
plt.ylabel("Precision")
plt.legend()
plt.grid(True)

# ---------------------- å›¾3ï¼šRecall æ›²çº¿ ----------------------
plt.subplot(2, 2, 3)
plt.plot(df["epoch"], df["metrics/recall(B)"], label="Recall", color='purple')
plt.title("Recall over Epochs")
plt.xlabel("Epoch")
plt.ylabel("Recall")
plt.legend()
plt.grid(True)

# ---------------------- å›¾4ï¼šmAP æ›²çº¿ ----------------------
plt.subplot(2, 2, 4)
plt.plot(df["epoch"], df["metrics/mAP50(B)"], label="mAP@0.5", color='teal')
plt.plot(df["epoch"], df["metrics/mAP50-95(B)"], label="mAP@0.5:0.95", color='brown')
plt.title("mAP over Epochs")
plt.xlabel("Epoch")
plt.ylabel("mAP")
plt.legend()
plt.grid(True)

# å¸ƒå±€ä¼˜åŒ– & æ˜¾ç¤ºå›¾åƒ
plt.tight_layout()
plt.show()
```


# è¯¾è®¾

&nbsp; &nbsp; &nbsp; ç”±äºé€‰è¯¾çš„åŸå› ï¼Œè¿™å­¦æœŸè¦åšå¥½å‡ ä¸ªè¯¾è®¾ï¼ˆ3ä¸ªå·¦å³ï¼‰ï¼Œç„¶åè‡ªå·±åˆç»å¸¸çŠ¯æ‡’ï¼Œå¾ˆå¤šå·¥ä½œéƒ½æ‹–åˆ°æœ€åå‡ å¤©æ‰åšï¼Œå¥½åœ¨è‡ªå·±é¬¼ç‚¹å­å¤š{% inlineimage 2.png, height=70px %}ï¼Œæœ€åéƒ½å¼„å®Œäº†ã€‚
{% btn 'https://7llb7h-my.sharepoint.com/:w:/g/personal/lisiran_7llb7h_onmicrosoft_com/EbnKQQrWSjBLhyCLb53-PPUBIcQbMQwu5NrZJYCAeHvn7Q?e=2dO1BZ',è¯¾è®¾1,far fa-hand-point-right,larger %}
{% btn 'https://7llb7h-my.sharepoint.com/:w:/g/personal/lisiran_7llb7h_onmicrosoft_com/EeqPU5zda9hFn4YXGHcm290BXb0_o_de9SiZL3-W6s7HZA?e=KixxeJ',è¯¾è®¾2,far fa-hand-point-right,blue larger %}
{% btn 'https://7llb7h-my.sharepoint.com/:w:/g/personal/lisiran_7llb7h_onmicrosoft_com/ESCrcb_yz0NEn3MfTqcWHDIBAgzsBwrSV3ohupuw7Ln9hQ?e=eebtMI',è¯¾è®¾3,far fa-hand-point-right,pink larger %}
å…¶ä¸­ä¸¤ä¸ªè¯¾è®¾æ˜¯ç‹¬ç«‹å®Œæˆçš„ï¼Œå¯¹æ²¡é”™ï¼Œè‡ªå·±å°±æ˜¯ä¸€ä¸ªç»„ï¼Œç„¶åæƒŠè®¶çš„å‘ç°ï¼Œä¸€ä¸ªäººåšè¯¾è®¾çš„æ•ˆç‡ç«Ÿç„¶å‡ºå¥‡çš„é«˜ï¼Œå®Œæˆåº¦ç”šè‡³è¶…è¿‡äº†ç»„é˜Ÿçš„è¯¾è®¾ä»»åŠ¡ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæˆ‘è§‰å¾—å¯ä»¥åœ¨ä¹‹å‰ä¸€ç¯‡åä¸ºâ€œä¹Œåˆä¹‹ä¼—â€çš„æ–‡ç« é‡Œæ‰¾åˆ°ç­”æ¡ˆã€‚

# æ¯”èµ›
&nbsp; &nbsp; &nbsp; æš‘å‡å¼€å§‹æ²¡å¤šä¹…ï¼Œå’Œå­¦æ ¡é‡Œçš„ä¸¤ä¸ªç ”ç©¶ç”Ÿå­¦é•¿ç»„é˜Ÿï¼ŒæŠ¥åäº†ä¸€å †æ¯”èµ›ï¼Œä¹±ä¸ƒå…«ç³Ÿçš„éƒ½æœ‰ï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯[2025å¹´ä¸­å›½é«˜æ ¡è®¡ç®—æœºå¤§èµ›-äººå·¥æ™ºèƒ½åˆ›æ„èµ›](http://aicontest.baidu.com/rules.html)ï¼Œåˆ°ç°åœ¨ä¹Ÿæ²¡æ•´å‡ºä»€ä¹ˆå¥½æ´»ï¼Œå¤§è‡´çš„æ€è·¯å°±æ˜¯å¤šæ¨¡æ€ï¼ˆçº¢å¤–ï¼Œè§†è§‰ï¼ŒåæŒ¯ï¼‰â€”â€”ç®—æ³•å»é›¾â€”â€”é™å™ªâ€”â€”AIç‰©ä½“æ£€æµ‹â€”â€”AIå»é›¾æ•ˆæœè¯„ä¼°ï¼Œä¸ªäººæ„Ÿè§‰æ²¡ä»€ä¹ˆåˆ›æ–°ç‚¹ã€‚
&nbsp; &nbsp; &nbsp; ä¸€å¼€å§‹æ„Ÿè§‰é™åˆ¶æœ‰ç‚¹å¤šï¼Œæ¯”å¦‚ä¸€å®šè¦ç”¨ç™¾åº¦çš„é‚£ä¸ªé£æµ†studioè®­ç»ƒå’Œéƒ¨ç½²ä»€ä¹ˆçš„ï¼Œåæ¥æ‰å‘ç°å…¶å®æ˜¯è‡ªå·±åˆ›æ„æœ‰ç‚¹æ¯ç«­äº†ï¼Œåœ¨AIè®­ç»ƒ-æ£€æµ‹æ–¹é¢æƒ³ä¸å‡ºä»€ä¹ˆæ–°èŠ±æ ·ï¼Œæƒ³ä¸å‡ºè¿™æ ·çš„AIè¿˜èƒ½æœ‰ä»€ä¹ˆå¥½ç©åˆå®ç”¨çš„åº”ç”¨åœºæ™¯ã€‚ç„¶åç°åœ¨è¿™ä¸ªé¡¹ç›®çš„æµç¨‹æ˜¯è¿™æ ·çš„ï¼šç”¨`AI`ç”Ÿæˆå‡ å¼ å¸¦é›¾çš„ç‰§åœºå›¾ï¼Œç„¶åç”¨`AI`å»é›¾ï¼Œç”¨`AI`æ£€æµ‹ç‰§åœºä¸­çš„ç‰›ç¾Šï¼Œæœ€åç”¨`AI`è¯„ä¼°å»é›¾æ•ˆæœï¼Œå…¨éƒ¨ä¸œè¥¿éƒ½æ˜¯AIåšçš„ï¼Œæ•´ä¸ªä¸œè¥¿å……æ»¡ç€ä¸€ç§åèµ›åšæœ‹å…‹çš„ç¦»å¥‡ä¸è’è¯{% inlineimage 5.png, height=90px %}ï¼Œæ˜æ˜å«â€œåˆ›æ„å¤§èµ›â€ï¼Œå´åˆåœ¨æŸç§ç¨‹åº¦æå¤§çš„é™åˆ¶äº†æˆ‘ä»¬çš„ä¸»è§‚èƒ½åŠ¨æ€§ã€‚
&nbsp; &nbsp; &nbsp; ä¸‹é¢æ˜¯ä¸€äº›åšçš„ä¸œè¥¿å’Œè¿‡ç¨‹ï¼š
{%asset_img 6.png %}
{%asset_img 7.png %}
{%asset_img 8.png %}
{%asset_img 9.png %}
{%asset_img 10.png %}
{%asset_img 11.png %}
{%asset_img 12.png %}
{%asset_img 13.png %}
{%asset_img 15.png %}
&nbsp; &nbsp; &nbsp; æœ¬æ¥æ²¡ä»€ä¹ˆçµæ„Ÿå°±çƒ¦èºï¼Œè¿™{% hideInline å‚»é€¼ä¸€æ ·çš„,â– â– ,#FF7242,#fff %}ç™¾åº¦é£æµ†studioè¿˜éš¾ç”¨ï¼Œä¸€ç›´æŠ¥é”™ï¼Œç›¸å…³çš„æ¨¡å‹åˆ°ç°åœ¨æˆ‘éƒ½æ²¡è®­ç»ƒå‡ºæ¥ï¼Œå±äºæ˜¯çº¢æ¸©å†’æ²¹äº†{% inlineimage 14.png, height=90px %}ï¼Œç™¾åº¦ï¼Œçœ‹çœ‹ä½ å¹²çš„å¥½äº‹ï¼ï¼ï¼
{% btn 'https://aistudio.baidu.com/projectdetail/9393583',ç™¾åº¦é£æµ†é¡¹ç›®åœ°å€,far fa-hand-point-right,pink larger %}
{% btn 'https://github.com/forever218/Eagle-eye',GITHUBé¡¹ç›®åœ°å€,far fa-hand-point-right,pink larger %}

# åšå®¢
&nbsp; &nbsp; &nbsp; å¥½ä¹…æ²¡æœ‰ç»´æŠ¤åšå®¢ï¼Œæœ‰äº›CDNå·²ç»å¤±æ•ˆï¼Œæ‰“å¼€æ§åˆ¶å°ä¸€ç‰‡çº¢è‰²ã€‚æ‰¾æ—¶é—´ä¿®å¤ä¸€ä¸‹ã€‚
{%asset_img 16.png %}
&nbsp; &nbsp; &nbsp; å¦å¤–ï¼Œæ–‡ç« çš„AIæ‘˜è¦è²Œä¼¼ä¹ŸæŒ‚äº†ï¼Œè¿Ÿç‚¹çœ‹çœ‹æ˜¯æ€ä¹ˆå›äº‹ã€‚

# è¿åŠ¨
&nbsp; &nbsp; &nbsp; æš‘å‡å›å®¶ä¹‹åç»å¸¸è¿åŠ¨ï¼ŒåŸºæœ¬æ¯å¤©ä¸‹åˆè·‘3åˆ°5å…¬é‡Œï¼Œç„¶åå»æ¥¼é¡¶æ‹‰ä¼¸10åˆ†é’Ÿï¼Œæœ€åå›å®¶é‡Œæ’¸ä¸€ä¼šé“ã€‚éš”ä¸‰å²”äº”å»æ¸¸æ³³ã€æ‰“ç¾½æ¯›çƒã€‚
{% asset_img 18.jpg %}
{% hideToggle ğŸ‘‰ç‚¹å‡»å±•å¼€æŸæ¬¡è·‘æ­¥è®°å½• %}
{% asset_img 17.jpg %}
{% endhideToggle %}
æœ€è¿‘åœ¨è°ƒæ•´è‡ªå·±çš„è·‘æ­¥å§¿åŠ¿ï¼Œæ›´åŠ åˆç†çš„æ­¥å¹…ï¼Œæ›´åŠ çŸ­çš„è§¦åœ°æ—¶é—´ï¼Œæ›´å¤§çš„å‚ç›´æ­¥å¹…æ¯”ã€‚è§¦åœ°æ—¶é—´è¶ŠçŸ­ï¼Œè·‘æ­¥çš„æ•ˆç‡å°±è¶Šé«˜ï¼Œä¼˜ç§€çš„è·‘è€…ä¸€èˆ¬æ˜¯åœ¨**220ms**å·¦å³ï¼Œæˆ‘ä¹‹å‰éƒ½æ˜¯**350ms**å¾€ä¸Šçš„ã€‚ä½†æˆ‘å‘ç°ï¼Œç¼©çŸ­è§¦åœ°æ—¶é—´æ„å‘³ç€éœ€è¦å°½å¯èƒ½å‰è„šæŒç€åœ°ï¼ˆæˆ‘ä¸€èˆ¬æ˜¯æ•´ä¸ªè„šæŒç€åœ°ï¼‰ï¼Œæœ‰ç§è¸®ç€è„šè·‘çš„æ„Ÿè§‰ï¼Œè·‘ä¸€ä¼šå°è…¿å°±ç´§çš„ä¸è¡Œï¼Œæ‰€ä»¥è¿˜åœ¨æ‰¾æé«˜è·‘æ­¥æ•ˆç‡çš„æ–¹æ³•ã€‚
{% asset_img 19.jpg %}

# åˆ›é€ 
## æ‘„å½±
&nbsp; &nbsp; &nbsp; **æ‹é—ªç”µæ•™ç¨‹ğŸŒ©ï¸**ï¼šè„šæ¶ï¼Œæ‰‹åŠ¨å¯¹ç„¦ï¼ˆæ— ç©·è¿œï¼‰ï¼Œ`ISO`100ï¼Œå…‰åœˆF22ï¼ŒBæ¡£ã€‚**åˆé€‚çš„å¤©æ°”**ï¼šä¹Œäº‘åˆšåˆšè¿‡å¢ƒï¼ˆæˆ–è€…ä¸æ˜¯å¤ªåšã€ä¸æ˜¯å¤ªä½çš„ä¹Œäº‘ï¼Œå³å°†åˆ°æ¥çš„å°é£æ˜¯æœ€ä½³é€‰æ‹©ï¼‰ï¼Œæœ€å¥½æ˜¯æ¥åœ°é—ªï¼ˆäº‘é—´é—ªä¸å¤ªå¥½æ‹ï¼Œè§’åº¦éš¾ä»¥æŠŠæ§ï¼‰ï¼Œå»æ¥¼é¡¶æ¶å¥½è„šæ¶è€å¿ƒç­‰å¾…å³å¯ã€‚å½“ç„¶äº†ï¼Œè¿™ä¸€åˆ‡çš„å‰ææ˜¯è¶³å¤Ÿçš„çƒ­çˆ±å’Œå…´è¶£ã€‚
&nbsp; &nbsp; &nbsp; è¯·æ³¨æ„<span style="color:red">ä¸€å®šè¦æ³¨æ„å®‰å…¨ï¼Œç¡®ä¿é—ªç”µä¸è‡ªå·±ä¹‹é—´æœ‰ç›¸å½“çš„è·ç¦»ï¼Œæˆ‘çš„å»ºè®®æ˜¯åªæœ‰å¬ä¸è§é›·å£°çš„é—ªç”µï¼Œæ‰èƒ½ä¸Šæ¥¼é¡¶æ‹æ‘„ã€‚å½“èƒ½å¬è§é›·å£°æ—¶ï¼Œè¯·ä¸è¦åˆ°ä»»ä½•éœ²å¤©çš„é«˜å¤„æ´»åŠ¨ã€‚</span>
&nbsp; &nbsp; &nbsp; ä¸‹é¢æ˜¯æˆ‘åœ¨25æ¥¼æ¥¼é¡¶æ‹æ‘„çš„é—ªç”µï¼š
{% asset_img 20.jpg %}
{% asset_img 21.jpg %}
{% asset_img 22.jpg %}
{% asset_img 23.jpg %}
é›·å…¬åŠ©æˆ‘ï¼ï¼ï¼è¿™æ¬¡è¿æ°”å¾ˆå¥½ï¼Œåœ¨æ¥¼é¡¶è¹²äº†3ä¸ªå¤šå°æ—¶ï¼Œæ‹åˆ°äº†è¿™äº›æ»¡æ„çš„é—ªç”µã€‚

## ä»£ç 
&nbsp; &nbsp; &nbsp; å¼„äº†ä¸€äº›æœ‰æ„æ€çš„ç¨‹åºï¼Œç¬¬ä¸€ä¸ªæ˜¯`å®‡å®™æ–‡æ˜æ¨¡æ‹Ÿå™¨`ï¼Œçµæ„Ÿæ¥æºäºã€Šä¸‰ä½“ã€‹ä¸­çš„é»‘æš—æ£®æ—ç†è®ºï¼Œè¿™é‡Œæˆ‘åªè¿›è¡Œäº†ç›¸å½“ç®€å•çš„æ¨¡æ‹Ÿï¼Œæ¥å±•ç¤ºå®‡å®™å„æ–‡æ˜é—´å¯èƒ½çš„è”ç³»ï¼ŒåŸºæœ¬é€»è¾‘ä¸ºï¼šæ–‡æ˜æ€»æ•°xï¼Œæ–‡æ˜ç¼–å·0-xï¼Œæ¯ä¸ªæ–‡æ˜å‘è¾¾ç¨‹åº¦0-xéšæœºåˆ†å¸ƒï¼Œæ¯è¿‡xç§’æ¯ä¸ªæ–‡æ˜å‘è¾¾ç¨‹åº¦éšæœºåŠ æˆ–å‡0-xï¼Œä¸¤ä¸ªæ–‡æ˜é—´å‘ç°çš„æ¦‚ç‡xï¼Œæ›´åŠ å‘è¾¾çš„æ–‡æ˜æ¶ˆç­ä½çº§æ–‡æ˜æ¦‚ç‡ä¸ºxï¼Œä½çº§æ–‡æ˜æ¶ˆç­é«˜çº§æ–‡æ˜çš„æ¦‚ç‡ä¸ºxï¼Œä¸¤ä¸ªæ–‡æ˜èåˆæˆä¸€ä¸ªå¤§æ–‡æ˜çš„æ¦‚ç‡ä¸ºxï¼Œèåˆçš„æ–‡æ˜ç¨‹åº¦åœ¨æƒ³åŠ çš„åŸºç¡€ä¸ŠéšæœºåŠ æˆ–å‡0-xï¼Œxéƒ½æ˜¯å¯ä»¥åœ¨ç¨‹åºé‡Œä¿®æ”¹çš„ã€‚
&nbsp; &nbsp; &nbsp; è¿™ä¸ªç¨‹åºåªå®šä¹‰äº†8ä¸ªå’Œæ–‡æ˜è¿›ç¨‹æœ‰å…³çš„å‚æ•°ï¼Œå®é™…ä¸Šå®‡å®™æ–‡æ˜ï¼ˆå¦‚æœå­˜åœ¨çš„è¯ï¼‰è¿œæ¯”è¿™å¤æ‚çš„å¤šçš„å¤šï¼Œæ‰€ä»¥å›¾ä¸€ä¹å°±å¥½äº†~~ã€‚è¯¥ç¨‹åºè¾ƒé•¿ï¼Œè¯·é…Œæƒ…å±•å¼€ï¼Œæˆ–è€…ç›´æ¥{% btn 'https://2am.top/2025/07/20/%E7%A2%8E%E7%A2%8E%E5%BF%B55/civilization_simulator.py',ä¸‹è½½æ–‡ä»¶,far fa-hand-point-right,pink larger %}è¿è¡Œã€‚  

{% asset_img 26.png %}  

```python
import tkinter as tk
from tkinter import ttk, scrolledtext
import random
import threading
import time
from dataclasses import dataclass
from typing import List, Dict
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import numpy as np
from datetime import datetime

@dataclass
class Civilization:
    id: int
    alive: bool
    initial_development: int
    current_development: int
    
    def __str__(self):
        status = "å­˜æ´»" if self.alive else "ç­ç»"
        return f"æ–‡æ˜{self.id}: {status}, åˆå§‹å‘è¾¾ç¨‹åº¦: {self.initial_development}, å½“å‰å‘è¾¾ç¨‹åº¦: {self.current_development}"

@dataclass
class SimulationEvent:
    timestamp: str
    event_type: str  # "extinction", "merge", "development"
    description: str
    civilizations_involved: List[int]
    
    def __str__(self):
        return f"[{self.timestamp}] {self.description}"

class CivilizationSimulator:
    def __init__(self, root):
        self.root = root
        self.root.title("æ–‡æ˜æ¨¡æ‹Ÿå™¨")
        self.root.geometry("1200x800")
        
        self.civilizations: List[Civilization] = []
        self.events: List[SimulationEvent] = []
        self.running = False
        self.simulation_thread = None
        self.step_counter = 0
        
        # å‚æ•°å˜é‡
        self.num_civilizations = tk.IntVar(value=10)
        self.time_interval = tk.DoubleVar(value=1.0)
        self.development_change_range = tk.IntVar(value=5)
        self.discovery_probability = tk.DoubleVar(value=0.1)
        self.advanced_destroy_probability = tk.DoubleVar(value=0.3)
        self.primitive_destroy_probability = tk.DoubleVar(value=0.05)
        self.merge_probability = tk.DoubleVar(value=0.2)
        self.merge_change_range = tk.IntVar(value=3)
        
        self.setup_ui()
        
    def setup_ui(self):
        # ä¸»æ¡†æ¶
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # å·¦ä¾§æ§åˆ¶é¢æ¿
        control_frame = ttk.LabelFrame(main_frame, text="æ§åˆ¶é¢æ¿", padding=10)
        control_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        
        # å‚æ•°è®¾ç½®
        ttk.Label(control_frame, text="æ–‡æ˜æ€»æ•°:").pack(anchor=tk.W)
        ttk.Spinbox(control_frame, from_=2, to=100, textvariable=self.num_civilizations, width=15).pack(pady=2)
        
        ttk.Label(control_frame, text="æ—¶é—´é—´éš”(ç§’):").pack(anchor=tk.W, pady=(10,0))
        ttk.Spinbox(control_frame, from_=0.1, to=10.0, increment=0.1, textvariable=self.time_interval, width=15).pack(pady=2)
        
        ttk.Label(control_frame, text="å‘è¾¾ç¨‹åº¦å˜åŒ–èŒƒå›´:").pack(anchor=tk.W, pady=(10,0))
        ttk.Spinbox(control_frame, from_=1, to=50, textvariable=self.development_change_range, width=15).pack(pady=2)
        
        ttk.Label(control_frame, text="å‘ç°æ¦‚ç‡:").pack(anchor=tk.W, pady=(10,0))
        ttk.Spinbox(control_frame, from_=0.01, to=1.0, increment=0.01, textvariable=self.discovery_probability, width=15).pack(pady=2)
        
        ttk.Label(control_frame, text="é«˜çº§æ–‡æ˜æ¶ˆç­æ¦‚ç‡:").pack(anchor=tk.W, pady=(10,0))
        ttk.Spinbox(control_frame, from_=0.01, to=1.0, increment=0.01, textvariable=self.advanced_destroy_probability, width=15).pack(pady=2)
        
        ttk.Label(control_frame, text="ä½çº§æ–‡æ˜æ¶ˆç­æ¦‚ç‡:").pack(anchor=tk.W, pady=(10,0))
        ttk.Spinbox(control_frame, from_=0.01, to=1.0, increment=0.01, textvariable=self.primitive_destroy_probability, width=15).pack(pady=2)
        
        ttk.Label(control_frame, text="èåˆæ¦‚ç‡:").pack(anchor=tk.W, pady=(10,0))
        ttk.Spinbox(control_frame, from_=0.01, to=1.0, increment=0.01, textvariable=self.merge_probability, width=15).pack(pady=2)
        
        ttk.Label(control_frame, text="èåˆå˜åŒ–èŒƒå›´:").pack(anchor=tk.W, pady=(10,0))
        ttk.Spinbox(control_frame, from_=1, to=20, textvariable=self.merge_change_range, width=15).pack(pady=2)
        
        # æ§åˆ¶æŒ‰é’®
        ttk.Button(control_frame, text="åˆå§‹åŒ–æ–‡æ˜", command=self.initialize_civilizations).pack(pady=(20,5), fill=tk.X)
        ttk.Button(control_frame, text="å¼€å§‹æ¨¡æ‹Ÿ", command=self.start_simulation).pack(pady=5, fill=tk.X)
        ttk.Button(control_frame, text="åœæ­¢æ¨¡æ‹Ÿ", command=self.stop_simulation).pack(pady=5, fill=tk.X)
        ttk.Button(control_frame, text="é‡ç½®", command=self.reset_simulation).pack(pady=5, fill=tk.X)
        
        # å³ä¾§æ˜¾ç¤ºåŒºåŸŸ
        display_frame = ttk.Frame(main_frame)
        display_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # åˆ›å»ºnotebookç”¨äºåˆ‡æ¢æ˜¾ç¤º
        self.notebook = ttk.Notebook(display_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # æ–‡æœ¬æ˜¾ç¤ºæ ‡ç­¾é¡µ
        text_frame = ttk.Frame(self.notebook)
        self.notebook.add(text_frame, text="æ–‡æ˜çŠ¶æ€")
        
        self.text_output = scrolledtext.ScrolledText(text_frame, wrap=tk.WORD, width=60, height=30)
        self.text_output.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # äº‹ä»¶è®°å½•æ ‡ç­¾é¡µ
        events_frame = ttk.Frame(self.notebook)
        self.notebook.add(events_frame, text="äº‹ä»¶è®°å½•")
        
        # äº‹ä»¶è®°å½•å·¥å…·æ 
        events_toolbar = ttk.Frame(events_frame)
        events_toolbar.pack(fill=tk.X, padx=10, pady=(10,5))
        
        ttk.Button(events_toolbar, text="æ¸…ç©ºè®°å½•", command=self.clear_events).pack(side=tk.LEFT)
        ttk.Button(events_toolbar, text="å¯¼å‡ºè®°å½•", command=self.export_events).pack(side=tk.LEFT, padx=(10,0))
        
        # äº‹ä»¶è¿‡æ»¤å™¨
        ttk.Label(events_toolbar, text="ç­›é€‰äº‹ä»¶:").pack(side=tk.LEFT, padx=(20,5))
        self.event_filter = ttk.Combobox(events_toolbar, values=["å…¨éƒ¨", "ç­ç»äº‹ä»¶", "èåˆäº‹ä»¶", "å‘å±•å˜åŒ–"], width=12)
        self.event_filter.set("å…¨éƒ¨")
        self.event_filter.bind("<<ComboboxSelected>>", self.filter_events)
        self.event_filter.pack(side=tk.LEFT)
        
        self.events_output = scrolledtext.ScrolledText(events_frame, wrap=tk.WORD, width=60, height=25)
        self.events_output.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # ç»Ÿè®¡ä¿¡æ¯æ ‡ç­¾é¡µ
        stats_frame = ttk.Frame(self.notebook)
        self.notebook.add(stats_frame, text="ç»Ÿè®¡ä¿¡æ¯")
        
        self.stats_output = scrolledtext.ScrolledText(stats_frame, wrap=tk.WORD, width=60, height=30)
        self.stats_output.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # å›¾è¡¨æ˜¾ç¤ºæ ‡ç­¾é¡µ
        chart_frame = ttk.Frame(self.notebook)
        self.notebook.add(chart_frame, text="å‘è¾¾ç¨‹åº¦å›¾è¡¨")
        
        self.fig = Figure(figsize=(8, 6), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, chart_frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # çŠ¶æ€æ 
        self.status_var = tk.StringVar(value="å‡†å¤‡å°±ç»ª")
        ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN).pack(side=tk.BOTTOM, fill=tk.X, pady=(10,0))
        
    def initialize_civilizations(self):
        """åˆå§‹åŒ–æ–‡æ˜"""
        self.civilizations.clear()
        self.events.clear()
        self.step_counter = 0
        num_civs = self.num_civilizations.get()
        
        for i in range(num_civs):
            initial_dev = random.randint(0, num_civs)
            civ = Civilization(
                id=i,
                alive=True,
                initial_development=initial_dev,
                current_development=initial_dev
            )
            self.civilizations.append(civ)
        
        # è®°å½•åˆå§‹åŒ–äº‹ä»¶
        self.add_event("initialization", f"åˆå§‹åŒ–äº† {num_civs} ä¸ªæ–‡æ˜", list(range(num_civs)))
        
        self.update_display()
        self.status_var.set(f"å·²åˆå§‹åŒ– {num_civs} ä¸ªæ–‡æ˜")
        
    def start_simulation(self):
        """å¼€å§‹æ¨¡æ‹Ÿ"""
        if not self.civilizations:
            self.status_var.set("è¯·å…ˆåˆå§‹åŒ–æ–‡æ˜")
            return
            
        if not self.running:
            self.running = True
            self.simulation_thread = threading.Thread(target=self.simulation_loop, daemon=True)
            self.simulation_thread.start()
            self.status_var.set("æ¨¡æ‹Ÿè¿è¡Œä¸­...")
            
    def stop_simulation(self):
        """åœæ­¢æ¨¡æ‹Ÿ"""
        self.running = False
        self.status_var.set("æ¨¡æ‹Ÿå·²åœæ­¢")
        
    def reset_simulation(self):
        """é‡ç½®æ¨¡æ‹Ÿ"""
        self.stop_simulation()
        self.civilizations.clear()
        self.events.clear()
        self.step_counter = 0
        self.text_output.delete(1.0, tk.END)
        self.events_output.delete(1.0, tk.END)
        self.stats_output.delete(1.0, tk.END)
        self.ax.clear()
        self.canvas.draw()
        self.status_var.set("å·²é‡ç½®")
        
    def simulation_loop(self):
        """æ¨¡æ‹Ÿä¸»å¾ªç¯"""
        while self.running:
            self.simulate_step()
            time.sleep(self.time_interval.get())
            
    def simulate_step(self):
        """æ‰§è¡Œä¸€æ­¥æ¨¡æ‹Ÿ"""
        self.step_counter += 1
        alive_civs = [civ for civ in self.civilizations if civ.alive]
        
        if len(alive_civs) <= 1:
            self.running = False
            winner = alive_civs[0] if alive_civs else None
            if winner:
                self.add_event("simulation_end", f"æ¨¡æ‹Ÿç»“æŸ - æ–‡æ˜{winner.id} æˆä¸ºæœ€åçš„å¹¸å­˜è€…ï¼", [winner.id])
            else:
                self.add_event("simulation_end", "æ¨¡æ‹Ÿç»“æŸ - æ‰€æœ‰æ–‡æ˜éƒ½å·²ç­ç»", [])
            self.root.after(0, lambda: self.status_var.set("æ¨¡æ‹Ÿç»“æŸ"))
            return
            
        # è®°å½•æ¯æ­¥å¼€å§‹
        if self.step_counter % 10 == 1:  # æ¯10æ­¥è®°å½•ä¸€æ¬¡
            alive_count = len(alive_civs)
            self.add_event("development", f"ç¬¬{self.step_counter}æ­¥: {alive_count}ä¸ªæ–‡æ˜ä»åœ¨å‘å±•", [civ.id for civ in alive_civs])
            
        # 1. æ–‡æ˜å‘è¾¾ç¨‹åº¦éšæœºå˜åŒ–
        development_changes = []
        for civ in alive_civs:
            old_dev = civ.current_development
            change = random.randint(-self.development_change_range.get(), self.development_change_range.get())
            civ.current_development = max(0, civ.current_development + change)
            
            # è®°å½•æ˜¾è‘—çš„å‘å±•å˜åŒ–
            if abs(change) >= self.development_change_range.get() // 2:
                direction = "å¤§å¹…æå‡" if change > 0 else "æ€¥å‰§è¡°é€€"
                development_changes.append(f"æ–‡æ˜{civ.id}{direction}(å˜åŒ–{change:+d})")
                
        if development_changes:
            self.add_event("development", f"å‘å±•å˜åŒ–: {', '.join(development_changes)}", 
                          [civ.id for civ in alive_civs if abs(civ.current_development - civ.initial_development) >= self.development_change_range.get() // 2])
            
        # 2. æ–‡æ˜é—´çš„ç›¸äº’ä½œç”¨
        for i, civ1 in enumerate(alive_civs):
            for j, civ2 in enumerate(alive_civs):
                if i >= j or not civ1.alive or not civ2.alive:
                    continue
                    
                # æ£€æŸ¥æ˜¯å¦å‘ç°å¯¹æ–¹
                if random.random() < self.discovery_probability.get():
                    self.handle_civilization_encounter(civ1, civ2)
                    
        # æ›´æ–°æ˜¾ç¤º
        self.root.after(0, self.update_display)
        
    def handle_civilization_encounter(self, civ1: Civilization, civ2: Civilization):
        """å¤„ç†æ–‡æ˜ç›¸é‡"""
        if not civ1.alive or not civ2.alive:
            return
            
        # ç¡®å®šå“ªä¸ªæ–‡æ˜æ›´å‘è¾¾
        if civ1.current_development > civ2.current_development:
            advanced, primitive = civ1, civ2
        elif civ2.current_development > civ1.current_development:
            advanced, primitive = civ2, civ1
        else:
            # å‘è¾¾ç¨‹åº¦ç›¸åŒï¼Œéšæœºé€‰æ‹©
            advanced, primitive = random.choice([(civ1, civ2), (civ2, civ1)])
            
        encounter_roll = random.random()
        
        # èåˆ
        if encounter_roll < self.merge_probability.get():
            self.merge_civilizations(advanced, primitive)
        # é«˜çº§æ–‡æ˜æ¶ˆç­ä½çº§æ–‡æ˜
        elif encounter_roll < self.merge_probability.get() + self.advanced_destroy_probability.get():
            primitive.alive = False
            self.add_event("extinction", 
                          f"é«˜çº§æ–‡æ˜{advanced.id}(å‘è¾¾ç¨‹åº¦{advanced.current_development}) æ¶ˆç­äº†ä½çº§æ–‡æ˜{primitive.id}(å‘è¾¾ç¨‹åº¦{primitive.current_development})", 
                          [advanced.id, primitive.id])
        # ä½çº§æ–‡æ˜æ¶ˆç­é«˜çº§æ–‡æ˜ï¼ˆå°æ¦‚ç‡äº‹ä»¶ï¼‰
        elif encounter_roll < (self.merge_probability.get() + 
                              self.advanced_destroy_probability.get() + 
                              self.primitive_destroy_probability.get()):
            advanced.alive = False
            self.add_event("extinction", 
                          f"ä½çº§æ–‡æ˜{primitive.id}(å‘è¾¾ç¨‹åº¦{primitive.current_development}) å¥‡è¿¹èˆ¬åœ°æ¶ˆç­äº†é«˜çº§æ–‡æ˜{advanced.id}(å‘è¾¾ç¨‹åº¦{advanced.current_development})", 
                          [primitive.id, advanced.id])
            
    def merge_civilizations(self, civ1: Civilization, civ2: Civilization):
        """èåˆä¸¤ä¸ªæ–‡æ˜"""
        old_dev1, old_dev2 = civ1.current_development, civ2.current_development
        
        # æ–°çš„å‘è¾¾ç¨‹åº¦ = ä¸¤è€…ä¹‹å’Œ + éšæœºå˜åŒ–
        base_development = civ1.current_development + civ2.current_development
        change = random.randint(-self.merge_change_range.get(), self.merge_change_range.get())
        new_development = max(0, base_development + change)
        
        # ä¿ç•™IDè¾ƒå°çš„æ–‡æ˜ï¼Œæ›´æ–°å…¶å±æ€§
        if civ1.id < civ2.id:
            survivor, absorbed = civ1, civ2
        else:
            survivor, absorbed = civ2, civ1
            
        survivor.current_development = new_development
        absorbed.alive = False
        
        self.add_event("merge", 
                      f"æ–‡æ˜{survivor.id}(å‘è¾¾ç¨‹åº¦{old_dev1}) å’Œæ–‡æ˜{absorbed.id}(å‘è¾¾ç¨‹åº¦{old_dev2}) èåˆæˆæ–°æ–‡æ˜{survivor.id}(å‘è¾¾ç¨‹åº¦{new_development}, å˜åŒ–{change:+d})", 
                      [survivor.id, absorbed.id])
        
    def add_event(self, event_type: str, description: str, civilizations_involved: List[int]):
        """æ·»åŠ äº‹ä»¶è®°å½•"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        event = SimulationEvent(
            timestamp=timestamp,
            event_type=event_type,
            description=description,
            civilizations_involved=civilizations_involved
        )
        self.events.append(event)
        
        # å®æ—¶æ›´æ–°äº‹ä»¶æ˜¾ç¤º
        def update_events():
            self.events_output.insert(tk.END, str(event) + "\n")
            self.events_output.see(tk.END)
        self.root.after(0, update_events)
        
    def clear_events(self):
        """æ¸…ç©ºäº‹ä»¶è®°å½•"""
        self.events.clear()
        self.events_output.delete(1.0, tk.END)
        
    def export_events(self):
        """å¯¼å‡ºäº‹ä»¶è®°å½•"""
        filename = f"civilization_events_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("æ–‡æ˜æ¨¡æ‹Ÿå™¨äº‹ä»¶è®°å½•\n")
                f.write("=" * 50 + "\n\n")
                for event in self.events:
                    f.write(str(event) + "\n")
            self.status_var.set(f"äº‹ä»¶è®°å½•å·²å¯¼å‡ºåˆ° {filename}")
        except Exception as e:
            self.status_var.set(f"å¯¼å‡ºå¤±è´¥: {str(e)}")
            
    def filter_events(self, event=None):
        """ç­›é€‰äº‹ä»¶æ˜¾ç¤º"""
        filter_type = self.event_filter.get()
        self.events_output.delete(1.0, tk.END)
        
        for event in self.events:
            show_event = False
            if filter_type == "å…¨éƒ¨":
                show_event = True
            elif filter_type == "ç­ç»äº‹ä»¶" and event.event_type == "extinction":
                show_event = True
            elif filter_type == "èåˆäº‹ä»¶" and event.event_type == "merge":
                show_event = True
            elif filter_type == "å‘å±•å˜åŒ–" and event.event_type == "development":
                show_event = True
                
            if show_event:
                self.events_output.insert(tk.END, str(event) + "\n")
                
    def update_statistics(self):
        """æ›´æ–°ç»Ÿè®¡ä¿¡æ¯"""
        self.stats_output.delete(1.0, tk.END)
        
        # åŸºæœ¬ç»Ÿè®¡
        total_civs = len(self.civilizations)
        alive_civs = [civ for civ in self.civilizations if civ.alive]
        dead_civs = [civ for civ in self.civilizations if not civ.alive]
        
        self.stats_output.insert(tk.END, "=== æ–‡æ˜ç»Ÿè®¡ ===\n")
        self.stats_output.insert(tk.END, f"æ€»æ–‡æ˜æ•°: {total_civs}\n")
        self.stats_output.insert(tk.END, f"å­˜æ´»æ–‡æ˜æ•°: {len(alive_civs)}\n")
        self.stats_output.insert(tk.END, f"ç­ç»æ–‡æ˜æ•°: {len(dead_civs)}\n")
        self.stats_output.insert(tk.END, f"å­˜æ´»ç‡: {len(alive_civs)/total_civs*100:.1f}%\n\n")
        
        if alive_civs:
            developments = [civ.current_development for civ in alive_civs]
            self.stats_output.insert(tk.END, "=== å­˜æ´»æ–‡æ˜å‘è¾¾ç¨‹åº¦ç»Ÿè®¡ ===\n")
            self.stats_output.insert(tk.END, f"å¹³å‡å‘è¾¾ç¨‹åº¦: {sum(developments)/len(developments):.1f}\n")
            self.stats_output.insert(tk.END, f"æœ€é«˜å‘è¾¾ç¨‹åº¦: {max(developments)} (æ–‡æ˜{alive_civs[developments.index(max(developments))].id})\n")
            self.stats_output.insert(tk.END, f"æœ€ä½å‘è¾¾ç¨‹åº¦: {min(developments)} (æ–‡æ˜{alive_civs[developments.index(min(developments))].id})\n\n")
        
        # äº‹ä»¶ç»Ÿè®¡
        extinction_events = [e for e in self.events if e.event_type == "extinction"]
        merge_events = [e for e in self.events if e.event_type == "merge"]
        
        self.stats_output.insert(tk.END, "=== äº‹ä»¶ç»Ÿè®¡ ===\n")
        self.stats_output.insert(tk.END, f"æ€»äº‹ä»¶æ•°: {len(self.events)}\n")
        self.stats_output.insert(tk.END, f"ç­ç»äº‹ä»¶: {len(extinction_events)}\n")
        self.stats_output.insert(tk.END, f"èåˆäº‹ä»¶: {len(merge_events)}\n")
        self.stats_output.insert(tk.END, f"æ¨¡æ‹Ÿæ­¥æ•°: {self.step_counter}\n\n")
        
        # æœ€æ´»è·ƒçš„æ–‡æ˜
        if self.events:
            civ_activity = {}
            for event in self.events:
                for civ_id in event.civilizations_involved:
                    civ_activity[civ_id] = civ_activity.get(civ_id, 0) + 1
                    
            if civ_activity:
                most_active = max(civ_activity.items(), key=lambda x: x[1])
                self.stats_output.insert(tk.END, f"æœ€æ´»è·ƒæ–‡æ˜: æ–‡æ˜{most_active[0]} (å‚ä¸{most_active[1]}æ¬¡äº‹ä»¶)\n")
                
        # è¯¦ç»†çš„å­˜æ´»æ–‡æ˜ä¿¡æ¯
        if alive_civs:
            self.stats_output.insert(tk.END, "\n=== å­˜æ´»æ–‡æ˜è¯¦æƒ… ===\n")
            for civ in sorted(alive_civs, key=lambda x: x.current_development, reverse=True):
                growth = civ.current_development - civ.initial_development
                growth_str = f"(æˆé•¿{growth:+d})" if growth != 0 else "(æ— å˜åŒ–)"
                self.stats_output.insert(tk.END, f"æ–‡æ˜{civ.id}: å½“å‰{civ.current_development}, åˆå§‹{civ.initial_development} {growth_str}\n")
        
    def update_display(self):
        """æ›´æ–°æ˜¾ç¤º"""
        # æ›´æ–°æ–‡æœ¬æ˜¾ç¤º
        self.text_output.delete(1.0, tk.END)
        alive_count = 0
        
        for civ in self.civilizations:
            self.text_output.insert(tk.END, str(civ) + "\n")
            if civ.alive:
                alive_count += 1
                
        self.text_output.insert(tk.END, f"\nå­˜æ´»æ–‡æ˜æ•°é‡: {alive_count}\n")
        
        # æ›´æ–°å›¾è¡¨
        self.update_chart()
        
        # æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        self.update_statistics()
        
    def update_chart(self):
        """æ›´æ–°å›¾è¡¨æ˜¾ç¤º"""
        self.ax.clear()
        
        alive_civs = [civ for civ in self.civilizations if civ.alive]
        dead_civs = [civ for civ in self.civilizations if not civ.alive]
        
        if alive_civs:
            alive_ids = [civ.id for civ in alive_civs]
            alive_developments = [civ.current_development for civ in alive_civs]
            self.ax.bar(alive_ids, alive_developments, color='green', alpha=0.7, label='å­˜æ´»æ–‡æ˜')
            
        if dead_civs:
            dead_ids = [civ.id for civ in dead_civs]
            dead_developments = [civ.current_development for civ in dead_civs]
            self.ax.bar(dead_ids, dead_developments, color='red', alpha=0.7, label='ç­ç»æ–‡æ˜')
            
        self.ax.set_xlabel('æ–‡æ˜ç¼–å·')
        self.ax.set_ylabel('å‘è¾¾ç¨‹åº¦')
        self.ax.set_title('æ–‡æ˜å‘è¾¾ç¨‹åº¦åˆ†å¸ƒ')
        self.ax.legend()
        self.ax.grid(True, alpha=0.3)
        
        self.canvas.draw()

def main():
    root = tk.Tk()
    app = CivilizationSimulator(root)
    root.mainloop()

if __name__ == "__main__":
    main()
```
å¦ä¸€ä¸ªæ˜¯é”®ç›˜ç›‘æ§ç¨‹åºï¼Œèƒ½ç»Ÿè®¡è¿è¡Œæ—¶å„ä¸ªé”®ç›˜æŒ‰é”®è¢«æŒ‰ä¸‹çš„æ¬¡æ•°ã€‚ä½†æ˜¯è¿™æ˜¯éç³»ç»Ÿæƒé™çº§åˆ«çš„ï¼ˆæ²¡æœ‰ç”¨pywinhookï¼Œç”¨çš„æ˜¯pynuptï¼‰,ä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼Œä¸€ç”¨è¿™ä¸ªç©æ„å°±å®¹æ˜“å¡æ­»ï¼Œæˆ‘ä¼°è®¡è·Ÿç³»ç»Ÿæƒé™é™åˆ¶æœ‰å…³ï¼Œæ‰€ä»¥ç›®å‰ä¸èƒ½è®°å½•æ¸¸æˆé”®ç›˜ï¼Œå³åœ¨ç©æ¸¸æˆæ—¶è¿™ä¸ªç¨‹åºæ˜¯ä¸å·¥ä½œçš„ï¼Œå…¶ä»–æ—¶å€™åŸºæœ¬èƒ½æ­£å¸¸è¿è¡Œã€‚ç¨‹åºä¾æ—§å¾ˆé•¿ï¼Œè¯·é…Œæƒ…å±•å¼€æˆ–{% btn 'https://2am.top/2025/07/20/%E7%A2%8E%E7%A2%8E%E5%BF%B55/keyboard-tracker-pynput.py',ä¸‹è½½æ–‡ä»¶,far fa-hand-point-right,pink larger %}è¿è¡Œã€‚
```python
import tkinter as tk
from tkinter import ttk, messagebox
import json
import os
from datetime import datetime
import threading
import time
import sys
import webbrowser
import sqlite3
import queue
from pynput import keyboard

class KeyboardTracker:
    def __init__(self):
        self.running = False
        self.start_time = None
        self.end_time = None
        self.listener = None
        # ä¿®æ”¹æ•°æ®åº“æ–‡ä»¶è·¯å¾„ï¼Œä½¿ç”¨ç¨‹åºæ‰€åœ¨ç›®å½•
        self.db_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "keyboard_stats.db")
        self.listener_thread = None
        # è½¯ä»¶è¯´æ˜ç½‘é¡µURL
        self.about_url = "https:2am.top"
        
        # æ•°å­—é”®ç›˜æ˜ å°„
        self.numpad_mapping = {
            96: "å°é”®ç›˜0", 97: "å°é”®ç›˜1", 98: "å°é”®ç›˜2", 99: "å°é”®ç›˜3",
            100: "å°é”®ç›˜4", 101: "å°é”®ç›˜5", 102: "å°é”®ç›˜6", 103: "å°é”®ç›˜7",
            104: "å°é”®ç›˜8", 105: "å°é”®ç›˜9", 106: "å°é”®ç›˜*", 107: "å°é”®ç›˜+",
            108: "å°é”®ç›˜Enter", 109: "å°é”®ç›˜-", 110: "å°é”®ç›˜.", 111: "å°é”®ç›˜/"
        }
        
        # ä½¿ç”¨é˜Ÿåˆ—å¤„ç†æŒ‰é”®äº‹ä»¶ï¼Œå‡è½»ä¸»çº¿ç¨‹è´Ÿæ‹…
        self.key_queue = queue.Queue()
        
        # ä½¿ç”¨å…¨å±€è®¡æ•°å˜é‡ï¼Œé¿å…é¢‘ç¹æ•°æ®åº“æŸ¥è¯¢
        self.total_count = 0
        
        # æ‰¹é‡æ’å…¥çš„ç¼“å†²åŒº
        self.key_buffer = {}
        self.buffer_size = 20  # ç¼“å†²åŒºå¤§å°
        self.last_flush_time = time.time()
        self.flush_interval = 5  # æ¯5ç§’å¼ºåˆ¶å†™å…¥ä¸€æ¬¡
        
        # çº¿ç¨‹æ§åˆ¶æ ‡å¿—
        self.worker_running = True
        
        # æ·»åŠ çº¿ç¨‹é”ï¼Œé¿å…å¤šçº¿ç¨‹èµ„æºç«äº‰ -- ä¿®å¤: å…ˆåˆå§‹åŒ–é”ï¼Œå†ä½¿ç”¨é”
        self._buffer_lock = threading.Lock()
        self._db_lock = threading.Lock()
        
        # ç¡®ä¿pynputåº“å¯ç”¨
        try:
            self.keyboard = keyboard
            print("å·²åŠ è½½pynputåº“")
        except ImportError:
            print("é”™è¯¯ï¼šæœªå®‰è£…pynputåº“ï¼Œè¯·å®‰è£…ï¼š")
            print("pip install pynput")
            messagebox.showerror("ä¾èµ–ç¼ºå¤±", "æœªå®‰è£…å¿…è¦çš„åº“ã€‚è¯·å®‰è£…pynputï¼š\npip install pynput")
            sys.exit(1)
        
        # åˆå§‹åŒ–æ•°æ®åº“
        self.init_database()
        
        # åŠ è½½ç¼“å­˜çš„æ€»è®¡æ•°
        self.load_total_count()
        
        # åˆ›å»ºGUI
        self.create_gui()
        
        # å¯åŠ¨æŒ‰é”®å¤„ç†çº¿ç¨‹
        self.start_db_worker()
    
    def init_database(self):
        """åˆå§‹åŒ–SQLiteæ•°æ®åº“"""
        try:
            # ç¡®ä¿æ•°æ®åº“ç›®å½•å­˜åœ¨
            db_dir = os.path.dirname(self.db_file)
            if not os.path.exists(db_dir) and db_dir:
                os.makedirs(db_dir)
                
            # è¿æ¥æ•°æ®åº“ï¼ˆé¿å…ä½¿ç”¨check_same_thread=Falseï¼Œæ”¹ç”¨é”æœºåˆ¶ï¼‰
            self.conn = sqlite3.connect(self.db_file)
            self.conn.execute('PRAGMA journal_mode=WAL')  # å¯ç”¨WALæ¨¡å¼æé«˜å¹¶å‘æ€§èƒ½
            self.conn.execute('PRAGMA synchronous=NORMAL')  # é™ä½åŒæ­¥çº§åˆ«æé«˜æ€§èƒ½
            self.conn.execute('PRAGMA temp_store=MEMORY')  # ä½¿ç”¨å†…å­˜ä¸´æ—¶è¡¨ï¼Œæé«˜æ€§èƒ½
            
            # åˆ›å»ºè¡¨
            self.conn.execute('''
                CREATE TABLE IF NOT EXISTS key_stats (
                    key_name TEXT PRIMARY KEY,
                    count INTEGER DEFAULT 0
                )
            ''')
            
            # åˆ›å»ºå…ƒæ•°æ®è¡¨
            self.conn.execute('''
                CREATE TABLE IF NOT EXISTS metadata (
                    key TEXT PRIMARY KEY,
                    value TEXT
                )
            ''')
            
            # åˆ›å»ºç´¢å¼•
            self.conn.execute('CREATE INDEX IF NOT EXISTS idx_key_name ON key_stats(key_name)')
            
            self.conn.commit()
            print(f"æˆåŠŸåˆå§‹åŒ–æ•°æ®åº“: {self.db_file}")
        except Exception as e:
            print(f"åˆå§‹åŒ–æ•°æ®åº“æ—¶å‡ºé”™: {e}")
            messagebox.showerror("æ•°æ®åº“é”™è¯¯", f"åˆå§‹åŒ–æ•°æ®åº“æ—¶å‡ºé”™: {e}\næ•°æ®åº“è·¯å¾„: {self.db_file}")
            sys.exit(1)
    
    def get_db_connection(self):
        """è·å–çº¿ç¨‹å®‰å…¨çš„æ•°æ®åº“è¿æ¥"""
        with self._db_lock:
            return sqlite3.connect(self.db_file)
    
    def load_total_count(self):
        """ä»æ•°æ®åº“åŠ è½½æ€»æŒ‰é”®æ¬¡æ•°"""
        try:
            with self._db_lock:
                cursor = self.conn.execute('SELECT SUM(count) FROM key_stats')
                result = cursor.fetchone()
                self.total_count = result[0] if result[0] is not None else 0
        except Exception as e:
            print(f"åŠ è½½æ€»è®¡æ•°æ—¶å‡ºé”™: {e}")
            self.total_count = 0
    
    def start_db_worker(self):
        """å¯åŠ¨æ•°æ®åº“å·¥ä½œçº¿ç¨‹ï¼Œå¤„ç†é˜Ÿåˆ—ä¸­çš„æŒ‰é”®äº‹ä»¶"""
        def worker():
            while self.worker_running:
                try:
                    # è·å–é˜Ÿåˆ—ä¸­çš„æŒ‰é”®æˆ–ç­‰å¾…è¶…æ—¶
                    try:
                        key_name = self.key_queue.get(timeout=0.5)
                        
                        # æ·»åŠ åˆ°ç¼“å†²åŒº
                        with self._buffer_lock:
                            if key_name in self.key_buffer:
                                self.key_buffer[key_name] += 1
                            else:
                                self.key_buffer[key_name] = 1
                            
                            # å¢åŠ æ€»è®¡æ•°
                            self.total_count += 1
                        
                        # æ ‡è®°ä»»åŠ¡å®Œæˆ
                        self.key_queue.task_done()
                    except queue.Empty:
                        # é˜Ÿåˆ—è¶…æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°ç¼“å†²åŒº
                        pass
                    
                    # æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°ç¼“å†²åŒº
                    current_time = time.time()
                    buffer_size = 0
                    time_elapsed = False
                    
                    with self._buffer_lock:
                        buffer_size = len(self.key_buffer)
                        time_elapsed = (current_time - self.last_flush_time) >= self.flush_interval
                    
                    if (buffer_size >= self.buffer_size or time_elapsed) and buffer_size > 0:
                        self.flush_buffer_to_db()
                        with self._buffer_lock:
                            self.last_flush_time = current_time
                    
                except Exception as e:
                    print(f"æ•°æ®åº“å·¥ä½œçº¿ç¨‹å‡ºé”™: {e}")
                    # é¿å…çº¿ç¨‹å´©æºƒå¯¼è‡´æ•´ä¸ªç¨‹åºæ— å“åº”
                    time.sleep(0.5)
        
        self.db_worker = threading.Thread(target=worker, daemon=True)
        self.db_worker.start()
    
    def flush_buffer_to_db(self):
        """å°†æŒ‰é”®ç¼“å†²åŒºå†™å…¥æ•°æ®åº“"""
        # å¤åˆ¶ç¼“å†²åŒºå¹¶æ¸…ç©ºï¼Œå‡å°‘é”çš„æŒæœ‰æ—¶é—´
        buffer_copy = {}
        with self._buffer_lock:
            if not self.key_buffer:
                return
            buffer_copy = self.key_buffer.copy()
            self.key_buffer.clear()
            
        if not buffer_copy:
            return
            
        try:
            # ä½¿ç”¨ç‹¬ç«‹è¿æ¥å’Œäº‹åŠ¡ï¼Œé¿å…é˜»å¡å…¶ä»–æ“ä½œ
            with self.get_db_connection() as conn:
                cursor = conn.cursor()
                # ä½¿ç”¨äº‹åŠ¡æ‰¹é‡æ›´æ–°
                cursor.execute('BEGIN TRANSACTION')
                
                for key_name, count in buffer_copy.items():
                    # ä½¿ç”¨UPSERTè¯­æ³•
                    cursor.execute('''
                        INSERT INTO key_stats (key_name, count) VALUES (?, ?)
                        ON CONFLICT(key_name) DO UPDATE SET count = count + ?
                    ''', (key_name, count, count))
                
                conn.commit()
            
        except Exception as e:
            print(f"å†™å…¥æ•°æ®åº“æ—¶å‡ºé”™: {e}")
            # å¦‚æœå†™å…¥å¤±è´¥ï¼Œæ¢å¤ç¼“å†²åŒº
            with self._buffer_lock:
                for key, count in buffer_copy.items():
                    if key in self.key_buffer:
                        self.key_buffer[key] += count
                    else:
                        self.key_buffer[key] = count
    
    def on_press(self, key):
        """æŒ‰é”®æŒ‰ä¸‹æ—¶çš„å›è°ƒå‡½æ•° (ç”¨äºpynput)"""
        try:
            # è·å–æŒ‰é”®åç§°
            key_name = self.get_key_name(key)
            
            # æ·»åŠ åˆ°é˜Ÿåˆ—ï¼Œç”±å·¥ä½œçº¿ç¨‹å¤„ç†
            if self.running:
                self.key_queue.put(key_name)
        except Exception as e:
            print(f"å¤„ç†æŒ‰é”®æ—¶å‡ºé”™: {e}")
    
    def get_key_name(self, key):
        """è·å–æŒ‰é”®çš„å‹å¥½åç§° (ç”¨äºpynput)"""
        try:
            # å¤„ç†æ•°å­—é”®ç›˜æŒ‰é”®
            if isinstance(key, keyboard.KeyCode):
                # æ£€æŸ¥æ˜¯å¦ä¸ºæ•°å­—é”®ç›˜æŒ‰é”®
                vk = key.vk if hasattr(key, 'vk') else None
                if vk is not None and vk in self.numpad_mapping:
                    return self.numpad_mapping[vk]
                
                # å¸¸è§„é”®ç›˜å­—ç¬¦
                if hasattr(key, 'char') and key.char is not None:
                    return key.char
                
                # å¦‚æœåªæœ‰vkï¼Œå°è¯•ä½¿ç”¨å®ƒ
                if vk is not None:
                    return f"é”®ç {vk}"
            
            # å¤„ç†ç‰¹æ®ŠæŒ‰é”®
            if isinstance(key, keyboard.Key):
                return key.name
            
            # é»˜è®¤è½¬æ¢
            return str(key).replace("'", "")
        except:
            # å¦‚æœæ— æ³•ç¡®å®šæŒ‰é”®åç§°ï¼Œè¿”å›åŸå§‹è¡¨ç¤º
            return str(key)
    
    def on_release(self, key):
        """æŒ‰é”®é‡Šæ”¾æ—¶çš„å›è°ƒå‡½æ•° (ç”¨äºpynput)"""
        # å¦‚æœä¸å†è¿è¡Œï¼Œåˆ™åœæ­¢ç›‘å¬
        if not self.running:
            return False
    
    def start_tracking(self):
        """å¼€å§‹è®°å½•æŒ‰é”®"""
        if not self.running:
            self.running = True
            self.start_time = datetime.now()
            self.status_var.set("çŠ¶æ€: æ­£åœ¨è®°å½•...")
            
            # ä½¿ç”¨pynput
            def start_listener():
                with keyboard.Listener(
                    on_press=self.on_press,
                    on_release=self.on_release) as listener:
                    self.listener = listener
                    try:
                        listener.join()
                    except Exception as e:
                        print(f"ç›‘å¬å™¨é”™è¯¯: {e}")
            
            # ç¡®ä¿ä¹‹å‰çš„çº¿ç¨‹å·²ç»ç»“æŸ
            if self.listener_thread and self.listener_thread.is_alive():
                self.running = False
                if hasattr(self, 'listener') and self.listener:
                    self.listener.stop()
                self.listener_thread.join(timeout=1.0)
            
            self.listener_thread = threading.Thread(target=start_listener, daemon=True)
            self.listener_thread.start()
            
            # æ›´æ–°UI
            self.start_button.config(state=tk.DISABLED)
            self.stop_button.config(state=tk.NORMAL)
            self.update_stats_display()
    
    def stop_tracking(self):
        """åœæ­¢è®°å½•æŒ‰é”®"""
        if self.running:
            self.running = False
            self.end_time = datetime.now()
            
            # åœæ­¢pynputç›‘å¬å™¨
            if hasattr(self, 'listener') and self.listener:
                try:
                    self.listener.stop()
                except:
                    pass
            
            # ç¡®ä¿çº¿ç¨‹æ­£ç¡®åœæ­¢ï¼ˆè®¾ç½®è¶…æ—¶é¿å…æ°¸ä¹…é˜»å¡ï¼‰
            if self.listener_thread and self.listener_thread.is_alive():
                try:
                    self.listener_thread.join(timeout=2.0)
                except:
                    pass
            
            # å¼ºåˆ¶åˆ·æ–°ç¼“å†²åŒº
            self.flush_buffer_to_db()
            
            # æ›´æ–°UI
            self.status_var.set("çŠ¶æ€: å·²åœæ­¢")
            self.start_button.config(state=tk.NORMAL)
            self.stop_button.config(state=tk.DISABLED)
            self.update_stats_display()
    
    def reset_data(self):
        """é‡ç½®æŒ‰é”®è®¡æ•°æ•°æ®"""
        if messagebox.askyesno("ç¡®è®¤é‡ç½®", "ç¡®å®šè¦é‡ç½®æ‰€æœ‰æŒ‰é”®è®¡æ•°æ•°æ®å—ï¼Ÿ"):
            try:
                # ç¡®ä¿åœæ­¢è®°å½•
                was_running = self.running
                if was_running:
                    self.stop_tracking()
                
                # æ¸…ç©ºå†…å­˜ä¸­çš„è®¡æ•°
                with self._buffer_lock:
                    self.total_count = 0
                    self.key_buffer.clear()
                
                # æ¸…ç©ºæ•°æ®åº“è¡¨
                with self.get_db_connection() as conn:
                    conn.execute("DELETE FROM key_stats")
                    conn.commit()
                
                # æ›´æ–°UI
                self.update_stats_display()
                messagebox.showinfo("é‡ç½®å®Œæˆ", "æŒ‰é”®è®¡æ•°æ•°æ®å·²é‡ç½®")
                
                # å¦‚æœä¹‹å‰åœ¨è®°å½•ï¼Œåˆ™é‡æ–°å¼€å§‹
                if was_running:
                    self.start_tracking()
            except Exception as e:
                print(f"é‡ç½®æ•°æ®æ—¶å‡ºé”™: {e}")
                messagebox.showerror("é‡ç½®å¤±è´¥", f"é‡ç½®æ•°æ®æ—¶å‡ºé”™: {e}")
    
    def get_top_keys(self, limit=100):
        """è·å–æŒ‰é”®ç‚¹å‡»æ¬¡æ•°æœ€å¤šçš„è®°å½•"""
        try:
            # åˆå¹¶ç¼“å†²åŒºä¸­çš„æ•°æ®å’Œæ•°æ®åº“ä¸­çš„æ•°æ®
            with self._buffer_lock:
                buffer_copy = self.key_buffer.copy()
            
            results = {}
            
            # ä»æ•°æ®åº“è·å–è®°å½•
            with self.get_db_connection() as conn:
                cursor = conn.execute('''
                    SELECT key_name, count FROM key_stats 
                    ORDER BY count DESC LIMIT ?
                ''', (limit,))
                
                for key_name, count in cursor:
                    # åŠ ä¸Šç¼“å†²åŒºä¸­çš„è®¡æ•°
                    buffer_count = buffer_copy.pop(key_name, 0)
                    results[key_name] = count + buffer_count
            
            # æ·»åŠ åªåœ¨ç¼“å†²åŒºä¸­çš„é”®
            for key_name, count in buffer_copy.items():
                if key_name in results:
                    results[key_name] += count
                else:
                    results[key_name] = count
            
            # è¿”å›æ’åºåçš„ç»“æœ
            return sorted(results.items(), key=lambda x: x[1], reverse=True)[:limit]
        except Exception as e:
            print(f"è·å–æ’åå‰åˆ—æŒ‰é”®æ—¶å‡ºé”™: {e}")
            return []
    
    def update_stats_display(self):
        """æ›´æ–°ç»Ÿè®¡æ˜¾ç¤ºï¼Œä½¿ç”¨åˆ†é¡µåŠ è½½å‡å°‘è´Ÿæ‹…"""
        try:
            # ä½¿ç”¨after_idleç¡®ä¿åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡ŒUIæ›´æ–°
            self.root.after_idle(self._do_update_stats_display)
        except Exception as e:
            print(f"å®‰æ’æ›´æ–°ç»Ÿè®¡æ˜¾ç¤ºæ—¶å‡ºé”™: {e}")
    
    def _do_update_stats_display(self):
        """å®é™…æ‰§è¡ŒUIæ›´æ–°æ“ä½œï¼ˆåœ¨ä¸»çº¿ç¨‹ï¼‰"""
        try:
            # è·å–å½“å‰é€‰æ‹©çš„è¡Œï¼Œä»¥ä¾¿æ›´æ–°åå¯ä»¥ä¿æŒé€‰æ‹©
            selected_items = self.tree.selection()
            selected_keys = []
            for item in selected_items:
                item_values = self.tree.item(item, 'values')
                if item_values:
                    selected_keys.append(item_values[0])
            
            # æ¸…ç©ºç°æœ‰é¡¹ç›®
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            # åŠ è½½å‰100ä¸ªæŒ‰é”®
            sorted_keys = self.get_top_keys(100)
            
            # æ’å…¥æ•°æ®
            for i, (key_name, count) in enumerate(sorted_keys):
                self.tree.insert('', i, values=(key_name, count))
            
            # å°è¯•æ¢å¤ä¹‹å‰çš„é€‰æ‹©
            for key in selected_keys:
                for item in self.tree.get_children():
                    if self.tree.item(item, 'values')[0] == key:
                        self.tree.selection_add(item)
                        break
            
            # æ›´æ–°æ€»è®¡
            self.total_var.set(f"æ€»æŒ‰é”®æ¬¡æ•°: {self.total_count}")
            
            # æ›´æ–°è¿è¡Œæ—¶é—´
            if self.start_time:
                end = self.end_time if self.end_time else datetime.now()
                duration = end - self.start_time
                hours, remainder = divmod(duration.seconds, 3600)
                minutes, seconds = divmod(remainder, 60)
                time_str = f"{hours}å°æ—¶ {minutes}åˆ†é’Ÿ {seconds}ç§’"
                self.time_var.set(f"è¿è¡Œæ—¶é—´: {time_str}")
        except Exception as e:
            print(f"æ›´æ–°ç»Ÿè®¡æ˜¾ç¤ºæ—¶å‡ºé”™: {e}")
    
    def export_data(self):
        """å¯¼å‡ºæ•°æ®åˆ°CSVæ–‡ä»¶"""
        try:
            # å¼ºåˆ¶åˆ·æ–°ç¼“å†²åŒº
            self.flush_buffer_to_db()
            
            filename = f"keyboard_stats_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            
            # è·å–æ‰€æœ‰æ•°æ®
            with self.get_db_connection() as conn:
                cursor = conn.execute('SELECT key_name, count FROM key_stats ORDER BY count DESC')
                rows = cursor.fetchall()
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("æŒ‰é”®,æ¬¡æ•°\n")
                for key_name, count in rows:
                    f.write(f"{key_name},{count}\n")
            messagebox.showinfo("å¯¼å‡ºæˆåŠŸ", f"æ•°æ®å·²å¯¼å‡ºè‡³ {filename}")
        except Exception as e:
            messagebox.showerror("å¯¼å‡ºå¤±è´¥", f"å¯¼å‡ºæ•°æ®æ—¶å‡ºé”™: {e}")
    
    def open_about_page(self):
        """æ‰“å¼€å…³äºé¡µé¢"""
        try:
            webbrowser.open(self.about_url)
        except Exception as e:
            messagebox.showerror("æ‰“å¼€å¤±è´¥", f"æ— æ³•æ‰“å¼€ç½‘é¡µ: {e}")
    
    def create_gui(self):
        """åˆ›å»ºå›¾å½¢ç”¨æˆ·ç•Œé¢"""
        self.root = tk.Tk()
        self.root.title("é”®ç›˜ä½¿ç”¨ç»Ÿè®¡")
        self.root.geometry("600x500")
        
        # åˆ›å»ºæ¡†æ¶
        control_frame = ttk.Frame(self.root, padding=10)
        control_frame.pack(fill=tk.X)
        
        stats_frame = ttk.Frame(self.root, padding=10)
        stats_frame.pack(fill=tk.BOTH, expand=True)
        
        # æ§åˆ¶æŒ‰é’®
        self.start_button = ttk.Button(control_frame, text="å¼€å§‹è®°å½•", command=self.start_tracking)
        self.start_button.pack(side=tk.LEFT, padx=5)
        
        self.stop_button = ttk.Button(control_frame, text="åœæ­¢è®°å½•", command=self.stop_tracking, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)
        
        self.reset_button = ttk.Button(control_frame, text="é‡ç½®æ•°æ®", command=self.reset_data)
        self.reset_button.pack(side=tk.LEFT, padx=5)
        
        self.export_button = ttk.Button(control_frame, text="å¯¼å‡ºCSV", command=self.export_data)
        self.export_button.pack(side=tk.LEFT, padx=5)
        
        # æ·»åŠ å…³äºæŒ‰é’®
        self.about_button = ttk.Button(control_frame, text="å…³äº", command=self.open_about_page)
        self.about_button.pack(side=tk.LEFT, padx=5)
        
        # çŠ¶æ€æ˜¾ç¤º
        status_frame = ttk.Frame(self.root, padding=5)
        status_frame.pack(fill=tk.X)
        
        self.status_var = tk.StringVar(value="çŠ¶æ€: å°±ç»ª")
        status_label = ttk.Label(status_frame, textvariable=self.status_var)
        status_label.pack(side=tk.LEFT, padx=5)
        
        self.total_var = tk.StringVar(value="æ€»æŒ‰é”®æ¬¡æ•°: 0")
        total_label = ttk.Label(status_frame, textvariable=self.total_var)
        total_label.pack(side=tk.LEFT, padx=15)
        
        self.time_var = tk.StringVar(value="è¿è¡Œæ—¶é—´: 0å°æ—¶ 0åˆ†é’Ÿ 0ç§’")
        time_label = ttk.Label(status_frame, textvariable=self.time_var)
        time_label.pack(side=tk.LEFT, padx=5)
        
        # åˆ›å»ºè¡¨æ ¼æ˜¾ç¤º
        columns = ('key', 'count')
        self.tree = ttk.Treeview(stats_frame, columns=columns, show='headings')
        self.tree.heading('key', text='æŒ‰é”®')
        self.tree.heading('count', text='æ¬¡æ•°')
        self.tree.column('key', width=100)
        self.tree.column('count', width=80)
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # æ·»åŠ æ»šåŠ¨æ¡
        scrollbar = ttk.Scrollbar(stats_frame, orient=tk.VERTICAL, command=self.tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.tree.configure(yscrollcommand=scrollbar.set)
        
        # æ·»åŠ åº“ä¿¡æ¯æ ‡ç­¾
        lib_text = "ä½¿ç”¨pynputåº“ (å¯èƒ½æ— æ³•æ•è·å…¨å±æ¸¸æˆæŒ‰é”®)"
        lib_label = ttk.Label(self.root, text=lib_text, foreground="gray")
        lib_label.pack(side=tk.BOTTOM, pady=5)
        
        # æ·»åŠ æ•°æ®åº“ä¿¡æ¯æ ‡ç­¾
        db_label = ttk.Label(self.root, text=f"ä½¿ç”¨SQLiteæ•°æ®åº“å­˜å‚¨: {self.db_file}", foreground="gray")
        db_label.pack(side=tk.BOTTOM, pady=0)
        
        # åŠ è½½å¹¶æ˜¾ç¤ºç°æœ‰æ•°æ®
        self.update_stats_display()
        
        # å½“çª—å£å…³é—­æ—¶ä¿å­˜æ•°æ®å¹¶åœæ­¢è®°å½•
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        # åˆå§‹åŒ–å®šæ—¶æ›´æ–°è®¡æ•°å™¨
        self._update_counter = 0
    
    def on_closing(self):
        """çª—å£å…³é—­æ—¶çš„å¤„ç†å‡½æ•°"""
        # åœæ­¢æŒ‰é”®è®°å½•
        if self.running:
            self.stop_tracking()
        
        # åœæ­¢å·¥ä½œçº¿ç¨‹
        self.worker_running = False
        
        # åˆ·æ–°å¹¶ç­‰å¾…é˜Ÿåˆ—æ¸…ç©º
        try:
            self.flush_buffer_to_db()
            # ç­‰å¾…é˜Ÿåˆ—å¤„ç†å®Œæˆ
            if hasattr(self, 'key_queue') and self.key_queue:
                try:
                    self.key_queue.join(timeout=2.0)
                except:
                    pass
        except:
            pass
        
        # ç­‰å¾…å·¥ä½œçº¿ç¨‹ç»“æŸ
        if hasattr(self, 'db_worker') and self.db_worker and self.db_worker.is_alive():
            try:
                self.db_worker.join(timeout=2.0)
            except:
                pass
        
        # å…³é—­æ•°æ®åº“
        try:
            if hasattr(self, 'conn') and self.conn:
                self.conn.close()
        except:
            pass
        
        # é”€æ¯çª—å£
        self.root.destroy()
    
    def periodic_update(self):
        """å®šæœŸæ›´æ–°UI"""
        try:
            if not hasattr(self, 'root') or not self.root:
                return  # å¦‚æœçª—å£å·²ç»å…³é—­ï¼Œåˆ™ä¸å†ç»§ç»­
                
            if self.running:
                # æ›´æ–°è¿è¡Œæ—¶é—´å’Œæ€»è®¡æ•°ï¼Œè¿™æ˜¯æ¯”è¾ƒè½»é‡çš„æ“ä½œ
                if self.start_time:
                    end = datetime.now()
                    duration = end - self.start_time
                    hours, remainder = divmod(duration.seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    time_str = f"{hours}å°æ—¶ {minutes}åˆ†é’Ÿ {seconds}ç§’"
                    self.time_var.set(f"è¿è¡Œæ—¶é—´: {time_str}")
                
                # æ¯10æ¬¡æ›´æ–°æ‰æ‰§è¡Œå®Œæ•´çš„ç»Ÿè®¡æ›´æ–°ï¼Œå‡å°‘UIè´Ÿæ‹…
                self._update_counter += 1
                if self._update_counter >= 10:
                    self._update_counter = 0
                    self.update_stats_display()
                else:
                    # ä»…æ›´æ–°æ€»è®¡æ•°
                    self.total_var.set(f"æ€»æŒ‰é”®æ¬¡æ•°: {self.total_count}")
            
            # é‡æ–°å®‰æ’ä¸‹ä¸€æ¬¡æ›´æ–°
            self.root.after(2000, self.periodic_update)
        except Exception as e:
            print(f"å®šæœŸæ›´æ–°UIæ—¶å‡ºé”™: {e}")
            # å‘ç”Ÿé”™è¯¯æ—¶ä¹Ÿè¦é‡æ–°å®‰æ’ï¼Œç¡®ä¿æ›´æ–°ä¸ä¼šä¸­æ–­
            self.root.after(2000, self.periodic_update)

    def run(self):
        """å¯åŠ¨åº”ç”¨ç¨‹åºä¸»å¾ªç¯"""
        # å¼€å§‹å®šæœŸæ›´æ–°UI
        self.root.after(2000, self.periodic_update)
        
        # å¦‚æœé…ç½®äº†è‡ªåŠ¨å¼€å§‹ï¼Œåˆ™å¯åŠ¨è®°å½•
        if self.get_auto_start():
            self.start_tracking()
        
        # å¯åŠ¨ä¸»å¾ªç¯
        self.root.mainloop()
    
    def get_auto_start(self):
        """è·å–è‡ªåŠ¨å¯åŠ¨è®¾ç½®"""
        try:
            with self._db_lock:
                cursor = self.conn.execute('SELECT value FROM metadata WHERE key = "auto_start"')
                result = cursor.fetchone()
                if result:
                    return result[0].lower() == 'true'
            return False
        except Exception as e:
            print(f"è·å–è‡ªåŠ¨å¯åŠ¨è®¾ç½®æ—¶å‡ºé”™: {e}")
            return False
    
    def set_auto_start(self, auto_start):
        """è®¾ç½®è‡ªåŠ¨å¯åŠ¨"""
        try:
            value = 'true' if auto_start else 'false'
            with self._db_lock:
                self.conn.execute('''
                    INSERT INTO metadata (key, value) VALUES (?, ?)
                    ON CONFLICT(key) DO UPDATE SET value = ?
                ''', ('auto_start', value, value))
                self.conn.commit()
            return True
        except Exception as e:
            print(f"è®¾ç½®è‡ªåŠ¨å¯åŠ¨æ—¶å‡ºé”™: {e}")
            return False

def main():
    """ä¸»å‡½æ•°"""
    try:
        # åˆ›å»ºå¹¶è¿è¡Œé”®ç›˜è·Ÿè¸ªå™¨
        tracker = KeyboardTracker()
        tracker.run()
    except Exception as e:
        print(f"ç¨‹åºè¿è¡Œæ—¶å‘ç”Ÿé”™è¯¯: {e}")
        messagebox.showerror("ç¨‹åºé”™è¯¯", f"ç¨‹åºè¿è¡Œæ—¶å‘ç”Ÿé”™è¯¯: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

```

## BLENDER
&nbsp; &nbsp; &nbsp; æœ€è¿‘ç ”ç©¶blenderçš„å…‰å½±éå¸¸ä¸Šå¤´ï¼Œå‘ç°ä¸€ç§ç”¨èŠ‚ç‚¹çš„åŠæ³•ï¼Œèƒ½è®©å…‰çº¿ä¹Ÿæœ‰æè´¨ï¼Œåœ¨åŠ ä¸Šä¸€ç‚¹å¯†åº¦å¾ˆä½çš„ä½“ç§¯ï¼Œçœ‹èµ·æ¥æœ‰è€¶ç¨£å…‰çš„æ„Ÿè§‰ï¼Œå¾ˆç¾å¦™ã€‚
{% asset_img 28.png %}
{% asset_img 27.png %}

# å…³äºæ„¤é’
&nbsp; &nbsp; &nbsp; æœ‰æ—¶æƒ³æƒ³ï¼Œè‡ªå·±ç®—ä¸ç®—ä¸ª**æ„¤é’**ï¼Ÿè¯´ç®—ä¹Ÿç®—ï¼Œä¸ç®—ä¹Ÿä¸ç®—ã€‚æ„¤é’çš„å®šä¹‰ï¼ˆæ™®éæ¥è®²ï¼‰æ˜¯â€œå¯¹ç¤¾ä¼šç°è±¡æœ‰å¼ºçƒˆçš„æƒ…ç»ªååº”ï¼Œç”šè‡³ä¼šå› æ­¤è€Œæ„¤æ€’â€ï¼Œæˆ‘å½“ç„¶ä¹Ÿå¯¹å¾ˆå¤šå½“ä¸‹çš„ç°è±¡æ„Ÿåˆ°ä¸æ»¡ï¼Œå´å¾ˆå°‘æ„Ÿåˆ°æ„¤æ€’ï¼Œæ›´å¤šçš„æ˜¯å¥½å¥‡è¿™èƒŒåçš„åŸå› æ˜¯ä»€ä¹ˆï¼Œæ˜¯ä»€ä¹ˆå¯¼è‡´äº†è¿™æ ·çš„ç°è±¡ï¼ˆè™½è¯´æƒ³æ¸…æ¥šäº†ä¹Ÿæ²¡ä»€ä¹ˆç”¨ï¼‰ï¼Œæ€è€ƒçš„è¿‡ç¨‹èƒ½å¸¦æ¥å¾ˆå¤šä¹è¶£ã€‚
&nbsp; &nbsp; &nbsp; æˆ–è€…ä¹Ÿå¯ä»¥åˆ†æä¸€ä¸‹ä¸ºä»€ä¹ˆæ„¤é’ä¼šâ€œæ„¤æ€’â€ï¼Œæˆ‘è§‰å¾—å¾ˆå¤§ä¸€éƒ¨åˆ†åŸå› æ˜¯å¯¹äºç°çŠ¶çš„æ— å¯å¥ˆä½•ï¼Œå¯¹æ— åŠ›æ”¹å˜ç°çŠ¶çš„ä¸€ç§æƒ…ç»ªå‘æ³„ï¼Œé€ æˆäº†æ„¤æ€’çš„æƒ…æ„Ÿã€‚æˆ‘å¯¹äºè‡ªå·±çš„èƒ½åŠ›é‚£æ˜¯ç›¸å½“çš„æ¸…æ¥šï¼ŒçŸ¥é“è‡ªå·±ä»æ¥å°±ä¸æ˜¯ä¸€ä¸ª**æ”¹å˜è€…**ï¼Œè€Œæ˜¯ä¸€ä¸ª**è®°å½•è€…**ã€**æ€è€ƒè€…**ï¼Œå°±åƒæˆ‘ä¹‹å‰åœ¨ã€Šæ•°å­—æ—¶ä»£ã€‹é‚£ç¯‡æ–‡ç« é‡Œè¯´çš„ä¸€æ ·ï¼Œ**æˆ‘ä»¬éƒ½æ˜¯æµ·é‡Œçš„é±¼ï¼ŒæŠ±æ€¨æµ·æ°´æ˜¯å’¸çš„æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼Œä¹Ÿä¸å¯èƒ½å»æ”¹å˜è¿™ä¸€äº‹å®**ï¼Œå¯¹è‡ªå·±æœ‰äº†æ¸…æ™°çš„å®šä½ï¼Œå°±ä¸ä¼šç»å¸¸æ„Ÿåˆ°æ— è°“çš„æ„¤æ€’äº†ã€‚
&nbsp; &nbsp; &nbsp; ä½†æ˜¯å¦ä¸€æ–¹é¢ï¼Œèƒ½æˆä¸ºæ„¤é’æ°æ°åˆè¯´æ˜ï¼Œä¸€ä¸ªäººå¯¹æœªæ¥æ˜¯å……æ»¡å¸Œæœ›çš„ï¼Œå¯¹ç”Ÿæ´»æ˜¯å……æ»¡çƒ­æƒ…çš„ï¼Œå¯¹äºè‡ªå·±å¯¹ä¸–ç•Œçš„æ”¹å˜æœ‰ç€æ»¡è…”çš„çƒ­è¡€ï¼Œè¿™æ˜¯ä¸€ç§å¾ˆç§¯æçš„å¿ƒæ€ï¼Œä¹Ÿå¾ˆç¬¦åˆå¹´è½»äººåº”è¯¥æœ‰çš„æ°”è´¨ã€‚å¹¶ä¸”è¿™ä¸ä¸Šé¢çš„è®ºè¿°å¹¶ä¸çŸ›ç›¾â€”â€”èƒ½ â€œå¯¹æ— åŠ›æ”¹å˜ç°çŠ¶çš„ä¸€ç§æƒ…ç»ªå‘æ³„â€ çš„å‰ææ˜¯ï¼Œä¸€ä¸ªäººå¾—å…ˆæœ‰æ”¹å˜ç°çŠ¶çš„æƒ³æ³•ã€‚æ‰€ä»¥æˆ‘çš„å»ºè®®æ˜¯ï¼Œæˆä¸ºä¸€ä¸ªâ€œé€‚å½“çš„â€æ„¤é’ï¼Œæ—¢ä¸è¢«æ„¤æ€’å†²æ˜äº†å¤´è„‘ï¼Œä¹Ÿä¸ä¼šå¤±å»å¯¹ç”Ÿæ´»çš„ä¿¡å¿ƒï¼Œè‹¥èƒ½åœ¨è¿™ä¸¤è€…ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼Œå®ä¹ƒäººç”Ÿä¸€å¤§ç¾äº‹ä¹Ÿã€‚{% inlineimage 25.png, height=90px %}


